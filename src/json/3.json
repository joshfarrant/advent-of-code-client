{
  "meta": {
    "createdAt": 1702294446563
  },
  "puzzle": {
    "day": 3,
    "title": "Gear Ratios"
  },
  "notes": "This one took a fair bit of thinking, but in the end I settled on what seemed like the most obvious (naive?) solutions.\n\nThe solutions to both parts are written in a very imperative style. Usually, I tend to write — or at least think — in an imperative style initially, then go back and refactor to a more functional style once I've got a working solution and a passing test suite to work against. I didn't do that here as I'm not sure of the best way to elegantly refactor these loops — especially the while loops — into a more declarative style. At a high level the code could still be considered functional as all of the functions are pure, but the loops are a bit of a mess and miss out on that declarative magic functional programming is known for.\n\nOne thing to note is that I had an off-by-one error in part 2 which I still don't particularly understand. The below line needed tweaking to get the correct answer:\n\n```ts\n// Part 1\nconst endColumn = clampColumn(column + numberLength + 1);\n\n// Part 2\nconst endColumn = clampColumn(column + numberLength);\n```\n\nI'd have expected the `+ 1` to be required in both cases as the `endColumn` variable is only used to define the search area for the special character. The way I use the variable is different between parts (a slice vs a for loop), but I still don't fully understand why the change was needed. I'll have to revisit this at some point as, at time of writing, I don't have any more time to spend on it.\n",
  "solutions": {
    "part1": "import { clamp, filter, map, nth, pipe, split, sum } from 'rambda';\n\ntype LocatedNumber = [Row: number, Column: number, Number: number];\n\nconst isNumber = (x: string): boolean => !isNaN(Number(x));\n\nconst locateNumbers = (lines: string[]): LocatedNumber[] => {\n  let numbers: LocatedNumber[] = [];\n\n  for (let row = 0; row < lines.length; row++) {\n    const line = lines[row];\n\n    for (let column = 0; column < line.length; column++) {\n      let currentChar = line[column];\n      let prevChar = column === 0 ? '.' : line[column - 1];\n      let charIdx = column;\n      let numberString = '';\n\n      if (isNumber(prevChar)) {\n        continue;\n      }\n\n      while (isNumber(currentChar) && charIdx < line.length) {\n        numberString += currentChar;\n        charIdx++;\n        currentChar = line[charIdx];\n      }\n\n      if (numberString.length > 0) {\n        const number = Number(numberString);\n\n        numbers.push([row, column, number]);\n      }\n    }\n  }\n\n  return numbers;\n};\n\nconst validateNumber = (lines: string[]) => {\n  const rowsCount = lines.length;\n  const columnsCount = lines[0].length;\n  const clampRow = clamp(0, rowsCount - 1);\n  const clampColumn = clamp(0, columnsCount - 1);\n\n  return ([row, column, number]: LocatedNumber): boolean => {\n    const numberLength = number.toString().length;\n    const startRow = clampRow(row - 1);\n    const endRow = clampRow(row + 1);\n    const startColumn = clampColumn(column - 1);\n    const endColumn = clampColumn(column + numberLength + 1);\n\n    let currentRow = startRow;\n    let allCharacters = '';\n\n    while (currentRow <= endRow) {\n      allCharacters += lines[currentRow].slice(startColumn, endColumn);\n      currentRow++;\n    }\n\n    return /[^0-9\\.]/g.test(allCharacters);\n  };\n};\n\nconst solution = (input: string): number => {\n  const lines = split('\\n')(input);\n  const validator = validateNumber(lines);\n\n  return pipe(\n    split('\\n'),\n    locateNumbers,\n    filter(validator),\n    map(x => x[2]),\n    sum,\n  )(input);\n};\n\nexport default solution;\n",
    "part2": "import { clamp, filter, map, pipe, reduce, split, sum } from 'rambda';\n\ntype LocatedNumber = [Row: number, Column: number, Number: number];\n\nconst isNumber = (x: string): boolean => !isNaN(Number(x));\n\nconst locateNumbers = (lines: string[]): LocatedNumber[] => {\n  let numbers: LocatedNumber[] = [];\n\n  for (let row = 0; row < lines.length; row++) {\n    const line = lines[row];\n\n    for (let column = 0; column < line.length; column++) {\n      let currentChar = line[column];\n      let prevChar = column === 0 ? '.' : line[column - 1];\n      let charIdx = column;\n      let numberString = '';\n\n      if (isNumber(prevChar)) {\n        continue;\n      }\n\n      while (isNumber(currentChar) && charIdx < line.length) {\n        numberString += currentChar;\n        charIdx++;\n        currentChar = line[charIdx];\n      }\n\n      if (numberString.length > 0) {\n        const number = Number(numberString);\n\n        numbers.push([row, column, number]);\n      }\n    }\n  }\n\n  return numbers;\n};\n\nconst validateNumber = (lines: string[]) => {\n  const rowsCount = lines.length;\n  const columnsCount = lines[0].length;\n  const clampRow = clamp(0, rowsCount - 1);\n  const clampColumn = clamp(0, columnsCount - 1);\n\n  return (\n    gearMap: Map<string, number[]>,\n    [row, column, number]: LocatedNumber,\n  ): Map<string, number[]> => {\n    const numberLength = number.toString().length;\n    const startRow = clampRow(row - 1);\n    const endRow = clampRow(row + 1);\n    const startColumn = clampColumn(column - 1);\n    const endColumn = clampColumn(column + numberLength);\n\n    for (let row = startRow; row <= endRow; row++) {\n      for (let column = startColumn; column <= endColumn; column++) {\n        if (lines[row][column] === '*') {\n          const key = JSON.stringify([row, column]);\n          const gears = gearMap.get(key) ?? [];\n\n          gearMap.set(key, [...gears, number]);\n        }\n      }\n    }\n\n    return gearMap;\n  };\n};\n\nconst product = (numbers: number[]): number =>\n  numbers.reduce((a, b) => a * b, 1);\n\nconst solution = (input: string): number => {\n  const lines = split('\\n')(input);\n  const validator = validateNumber(lines);\n\n  return pipe(\n    split('\\n'),\n    locateNumbers,\n    reduce(validator, new Map()),\n    map => Array.from(map.values()),\n    filter(gears => gears.length === 2),\n    map(product),\n    sum,\n  )(input);\n};\n\nexport default solution;\n"
  }
}