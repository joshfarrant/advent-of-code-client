{
  "meta": {
    "createdAt": 1764928354586
  },
  "puzzle": {
    "day": 4,
    "title": "Printing Department"
  },
  "notes": "I was expecting part 2 to be more complicated than it turned out to be, so this all ended up being pretty straightforward.\n\nI could tidy up my solution slightly by not having `removeRolls` mutate the original `grid`, but it's no big deal that it does.\n",
  "solutions": {
    "part1": "type Grid = string[][];\n\nconst RADIUS = 1;\nconst ROLL = '@';\n\nconst createGridChecker =\n  (grid: Grid) =>\n  (centerY: number, centerX: number): boolean => {\n    const maxX = grid[0].length - 1;\n    const maxY = grid.length - 1;\n\n    let adjacentRolls = 0;\n\n    for (let dy = -1 * RADIUS; dy <= RADIUS; dy++) {\n      for (let dx = -1 * RADIUS; dx <= RADIUS; dx++) {\n        // We don't care about the center cell\n        if (dx === 0 && dy === 0) continue;\n\n        const x = centerX + dx;\n        const y = centerY + dy;\n\n        if (x < 0 || x > maxX || y < 0 || y > maxY) continue;\n\n        if (grid[y][x] === ROLL) {\n          adjacentRolls += 1;\n        }\n\n        if (adjacentRolls >= 4) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\nexport default (input: string): number => {\n  const grid = input.split('\\n').map(line => line.split('')) as Grid;\n\n  const rollIsAccessible = createGridChecker(grid);\n\n  let accessibleRolls = 0;\n\n  for (let y = 0; y < grid.length; y++) {\n    for (let x = 0; x < grid[0].length; x++) {\n      if (grid[y][x] === ROLL && rollIsAccessible(y, x)) {\n        accessibleRolls += 1;\n      }\n    }\n  }\n\n  return accessibleRolls;\n};\n",
    "part2": "type Grid = string[][];\n\nconst RADIUS = 1;\nconst ROLL = '@';\n\nconst createGridChecker =\n  (grid: Grid) =>\n  (centerY: number, centerX: number): boolean => {\n    const maxX = grid[0].length - 1;\n    const maxY = grid.length - 1;\n\n    let adjacentRolls = 0;\n\n    for (let dy = -1 * RADIUS; dy <= RADIUS; dy++) {\n      for (let dx = -1 * RADIUS; dx <= RADIUS; dx++) {\n        // We don't care about the center cell\n        if (dx === 0 && dy === 0) continue;\n\n        const x = centerX + dx;\n        const y = centerY + dy;\n\n        if (x < 0 || x > maxX || y < 0 || y > maxY) continue;\n\n        if (grid[y][x] === ROLL) {\n          adjacentRolls += 1;\n        }\n\n        if (adjacentRolls >= 4) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n/**\n * Note that this fn mutates the provided grid.\n * We could do a deep copy, but it's fine in this situation.\n */\nconst removeRolls = (\n  grid: Grid,\n): { rollsRemoved: number; updatedGrid: Grid } => {\n  const rollIsAccessible = createGridChecker(grid);\n\n  const accessibleRollLocations: [number, number][] = [];\n\n  for (let y = 0; y < grid.length; y++) {\n    for (let x = 0; x < grid[0].length; x++) {\n      if (grid[y][x] === ROLL && rollIsAccessible(y, x)) {\n        accessibleRollLocations.push([x, y]);\n      }\n    }\n  }\n\n  for (const [x, y] of accessibleRollLocations) {\n    grid[y][x] = 'X';\n  }\n\n  return {\n    rollsRemoved: accessibleRollLocations.length,\n    updatedGrid: grid,\n  };\n};\n\nexport default (input: string): number => {\n  let grid = input.split('\\n').map(line => line.split('')) as Grid;\n  let totalRollsRemoved = 0;\n\n  while (true) {\n    const { rollsRemoved, updatedGrid } = removeRolls(grid);\n\n    if (rollsRemoved === 0) {\n      return totalRollsRemoved;\n    }\n\n    totalRollsRemoved += rollsRemoved;\n    grid = updatedGrid;\n  }\n};\n"
  }
}