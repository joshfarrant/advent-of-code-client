{
  "meta": {
    "createdAt": 1702294446563
  },
  "puzzle": {
    "day": 4,
    "title": "Scratchcards"
  },
  "notes": "This was relatively straightforward. I was able to reuse a lot of code between the two parts. The majority of the code is just parsing the numbers from the string, the implementation is pretty simple.\n\nI'm sure there must be a faster way to do part 2. I'd imagine it can all be done mathematically without the need for nested loops, given the list of scores. Figuring out how to do that is beyond my skill though.\n",
  "solutions": {
    "part1": "import {\n  filter,\n  intersection,\n  map,\n  match,\n  nth,\n  pipe,\n  split,\n  sum,\n  trim,\n} from 'rambda';\n\nconst getFirstMatch = (regex: RegExp) =>\n  pipe<[string], string[], string>(match(regex), nth(1));\n\nconst oneOrMoreSpacesRegex = /\\s+/g;\nconst parseNumbersFromString = pipe(\n  split(oneOrMoreSpacesRegex),\n  map(pipe(trim, Number)),\n);\n\nconst winningNumbersRegex = /:\\s*(.*?)\\s*\\|/;\nconst parseWinningNumbers = pipe(\n  getFirstMatch(winningNumbersRegex),\n  parseNumbersFromString,\n);\n\nconst myNumbersRegex = /\\|\\s*(.*?)\\s*$/;\nconst parseMyNumbers = pipe(\n  getFirstMatch(myNumbersRegex),\n  parseNumbersFromString,\n);\n\nconst calculateScore = (x: number) => Math.pow(2, x - 1);\n\nexport default pipe(\n  split('\\n'),\n  map(line => {\n    const myNumbers = parseMyNumbers(line);\n    const winningNumbers = parseWinningNumbers(line);\n\n    return intersection(myNumbers, winningNumbers).length;\n  }),\n  filter(x => x > 0),\n  map(calculateScore),\n  sum,\n);\n",
    "part2": "import {\n  always,\n  intersection,\n  map,\n  match,\n  nth,\n  pipe,\n  reduce,\n  split,\n  sum,\n  times,\n  trim,\n} from 'rambda';\n\nconst getFirstMatch = (regex: RegExp) =>\n  pipe<[string], string[], string>(match(regex), nth(1));\n\nconst oneOrMoreSpacesRegex = /\\s+/g;\nconst parseNumbersFromString = pipe(\n  split(oneOrMoreSpacesRegex),\n  map(pipe(trim, Number)),\n);\n\nconst winningNumbersRegex = /:\\s*(.*?)\\s*\\|/;\nconst parseWinningNumbers = pipe(\n  getFirstMatch(winningNumbersRegex),\n  parseNumbersFromString,\n);\n\nconst myNumbersRegex = /\\|\\s*(.*?)\\s*$/;\nconst parseMyNumbers = pipe(\n  getFirstMatch(myNumbersRegex),\n  parseNumbersFromString,\n);\n\nconst incrementSubsequentCards = (\n  cards: number[],\n  score: number,\n  i: number,\n) => {\n  const numberOfCards = cards[i];\n\n  for (let j = 0; j < score; j++) {\n    cards[i + j + 1] += numberOfCards;\n  }\n\n  return cards;\n};\n\nconst processScores = (scores: number[]): number[] => {\n  const initialCards = times(always(1), scores.length);\n\n  return reduce(incrementSubsequentCards, initialCards)(scores);\n};\n\nexport default pipe(\n  split('\\n'),\n  map(line => {\n    const myNumbers = parseMyNumbers(line);\n    const winningNumbers = parseWinningNumbers(line);\n\n    return intersection(myNumbers, winningNumbers).length;\n  }),\n  processScores,\n  sum,\n);\n"
  }
}