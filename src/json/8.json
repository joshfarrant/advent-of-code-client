{
  "meta": {
    "createdAt": 1733755854367
  },
  "puzzle": {
    "day": 8,
    "title": "Resonant Collinearity"
  },
  "notes": "",
  "solutions": {
    "part1": "type Coordinate = [y: number, x: number];\nconst getCoordinate =\n  (width: number) =>\n  (index: number): Coordinate =>\n    [Math.floor(index / width), index % width];\n\nconst buildNodeMap = (input: string, width: number) => {\n  const map = new Map<string, Coordinate[]>();\n  const getCoordinateOnGrid = getCoordinate(width);\n\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    if (char === '.') continue;\n\n    const coordinates = map.get(char) || [];\n\n    const coordinate = getCoordinateOnGrid(i);\n    coordinates.push(coordinate);\n    map.set(char, coordinates);\n  }\n\n  return map;\n};\n\nconst isInBounds =\n  (width: number, height: number) => (coordinate: Coordinate) => {\n    const [y, x] = coordinate;\n    return y >= 0 && y < height && x >= 0 && x < width;\n  };\n\nexport default (input: string): number => {\n  const width = input.indexOf('\\n');\n  const inputString = input.replaceAll('\\n', '');\n  const height = inputString.length / width;\n\n  const nodeMap = buildNodeMap(inputString, width);\n\n  const antinodes = new Set<string>();\n\n  const isInInputBounds = isInBounds(width, height);\n\n  nodeMap.forEach(nodes => {\n    for (let i = 0; i < nodes.length - 1; i++) {\n      const node = nodes[i];\n\n      for (let j = i + 1; j < nodes.length; j++) {\n        const otherNode = nodes[j];\n        const [dy, dx] = [otherNode[0] - node[0], otherNode[1] - node[1]];\n\n        let antinode: Coordinate = [otherNode[0] + dy, otherNode[1] + dx];\n\n        if (isInInputBounds(antinode)) {\n          antinodes.add(antinode.join(','));\n        }\n\n        antinode = [node[0] - dy, node[1] - dx];\n\n        if (isInInputBounds(antinode)) {\n          antinodes.add(antinode.join(','));\n        }\n      }\n    }\n  });\n\n  return antinodes.size;\n};\n",
    "part2": "type Coordinate = [y: number, x: number];\nconst getCoordinate =\n  (width: number) =>\n  (index: number): Coordinate =>\n    [Math.floor(index / width), index % width];\n\nconst buildNodeMap = (input: string, width: number) => {\n  const map = new Map<string, Coordinate[]>();\n  const getCoordinateOnGrid = getCoordinate(width);\n\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    if (char === '.') continue;\n\n    const coordinates = map.get(char) || [];\n\n    const coordinate = getCoordinateOnGrid(i);\n    coordinates.push(coordinate);\n    map.set(char, coordinates);\n  }\n\n  return map;\n};\n\nconst isInBounds =\n  (width: number, height: number) => (coordinate: Coordinate) => {\n    const [y, x] = coordinate;\n    return y >= 0 && y < height && x >= 0 && x < width;\n  };\n\nexport default (input: string): number => {\n  const width = input.indexOf('\\n');\n  const inputString = input.replaceAll('\\n', '');\n  const height = inputString.length / width;\n\n  const nodeMap = buildNodeMap(inputString, width);\n\n  const antinodes = new Set<string>();\n\n  const isInInputBounds = isInBounds(width, height);\n\n  nodeMap.forEach(nodes => {\n    for (let i = 0; i < nodes.length - 1; i++) {\n      const node = nodes[i];\n\n      antinodes.add(node.join(','));\n\n      for (let j = i + 1; j < nodes.length; j++) {\n        const otherNode = nodes[j];\n\n        antinodes.add(otherNode.join(','));\n\n        const [dy, dx] = [otherNode[0] - node[0], otherNode[1] - node[1]];\n\n        let antinode: Coordinate = [otherNode[0] + dy, otherNode[1] + dx];\n\n        while (isInInputBounds(antinode)) {\n          antinodes.add(antinode.join(','));\n          antinode = [antinode[0] + dy, antinode[1] + dx];\n        }\n\n        antinode = [node[0] - dy, node[1] - dx];\n\n        while (isInInputBounds(antinode)) {\n          antinodes.add(antinode.join(','));\n          antinode = [antinode[0] - dy, antinode[1] - dx];\n        }\n      }\n    }\n  });\n\n  return antinodes.size;\n};\n"
  }
}