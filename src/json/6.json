{
  "meta": {
    "createdAt": 1765014972902
  },
  "puzzle": {
    "day": 6,
    "title": "Trash Compactor"
  },
  "notes": "Part one here was pretty straightforward, but part two took some thinking.\n\nI went through a few different approaches — changing my approach significantly when I spotted that numbers can be left or right aligned — before realising that I could just process all lines together from right-to-left, then top to bottom for each column. When we get to an operator we the know we've processed all the numbers in that block and we can then perform the calculation and add the result to the total.\n\nI'm a bit ill as I do this and my solution nearly reflected that as I came quite close to using an `eval`, but in the end clearer heads prevailed and I'm quite happy with my operator object and `reduce` combo.\n",
  "solutions": {
    "part1": "const add = (a: number, b: number) => a + b;\nconst multiply = (a: number, b: number) => a * b;\n\nconst operationsMap = new Map([\n  ['+', add],\n  ['*', multiply],\n]);\n\nexport default (input: string): number => {\n  const arr2d = input.split('\\n').map(line => line.trim().split(/\\s+/));\n\n  let total = 0;\n\n  for (let x = 0; x < arr2d[0].length; x++) {\n    const operationSymbol = arr2d.at(-1)![x];\n    const operation = operationsMap.get(operationSymbol)!;\n\n    let runningTotal = 0;\n\n    for (let y = 0; y < arr2d.length - 1; y++) {\n      const value = Number(arr2d[y][x]);\n\n      if (runningTotal === 0 && operation === multiply) {\n        runningTotal = operation(1, value);\n      } else {\n        runningTotal = operation(runningTotal, value);\n      }\n    }\n\n    total += runningTotal;\n  }\n\n  return total;\n};\n",
    "part2": "const add = (a: number, b: number) => a + b;\nconst multiply = (a: number, b: number) => a * b;\n\nconst operationsMap = {\n  '+': add,\n  '*': multiply,\n};\n\ntype SupportedOperation = keyof typeof operationsMap;\nconst isValidOperation = (char: string): char is SupportedOperation =>\n  Object.keys(operationsMap).includes(char);\n\nconst getOperation = (char: SupportedOperation) => operationsMap[char];\n\nexport default (input: string): number => {\n  const lines = input.split('\\n');\n\n  const rowCount = lines.length;\n  const columnCount = Math.max(...lines.map(line => line.length));\n\n  let total = 0;\n\n  let numbers: string[] = [];\n\n  let localColumn = 0;\n\n  for (let c = columnCount - 1; c >= 0; c--) {\n    for (let r = 0; r < rowCount; r++) {\n      const row = lines[r];\n      if (c < row.length) {\n        const char = row[c];\n\n        if (char === ' ') continue;\n\n        if (isValidOperation(char)) {\n          const operation = getOperation(char);\n\n          total += numbers.reduce(\n            (a, c) => operation(a, Number(c)),\n            operation === multiply ? 1 : 0,\n          );\n\n          numbers = [];\n          localColumn = 0;\n        } else {\n          const existingChars = numbers[localColumn];\n\n          numbers[localColumn] = existingChars\n            ? numbers[localColumn] + char\n            : char;\n        }\n      }\n    }\n\n    localColumn++;\n  }\n\n  return total;\n};\n"
  }
}