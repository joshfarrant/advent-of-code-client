{
  "meta": {
    "createdAt": 1764579151852
  },
  "puzzle": {
    "day": 12,
    "title": "Garden Groups"
  },
  "notes": "",
  "solutions": {
    "part1": "type Coordinate = [number, number];\ntype Grid = string[][];\n\nconst getNeighbors = (grid: Grid, [x, y]: Coordinate): Coordinate[] => {\n  const neighbors: Coordinate[] = [\n    [x + 1, y],\n    [x - 1, y],\n    [x, y + 1],\n    [x, y - 1],\n  ];\n\n  return neighbors.filter(\n    ([nx, ny]) => nx >= 0 && nx < grid[0].length && ny >= 0 && ny < grid.length,\n  );\n};\n\nconst pointToString = ([x, y]: Coordinate): string => `${x},${y}`;\n\nconst findRegion = (\n  grid: Grid,\n  start: Coordinate,\n  visited: Set<string>,\n): Set<string> => {\n  const region = new Set<string>();\n  const queue: Coordinate[] = [start];\n  const targetChar = grid[start[1]][start[0]];\n\n  while (queue.length > 0) {\n    const current = queue.shift()!;\n    const currentStr = pointToString(current);\n\n    if (visited.has(currentStr)) continue;\n\n    visited.add(currentStr);\n    region.add(currentStr);\n\n    const newNeighbors = getNeighbors(grid, current).filter(n => {\n      const [nx, ny] = n;\n      return grid[ny][nx] === targetChar && !visited.has(pointToString(n));\n    });\n\n    queue.push(...newNeighbors);\n  }\n\n  return region;\n};\n\nconst calculatePerimeter = (grid: Grid, region: Set<string>): number => {\n  let perimeter = 0;\n\n  for (const pointStr of region) {\n    const [x, y] = pointStr.split(',').map(Number);\n    const char = grid[y][x];\n\n    const sides: Coordinate[] = [\n      [x + 1, y],\n      [x - 1, y],\n      [x, y + 1],\n      [x, y - 1],\n    ];\n\n    sides.forEach(([nx, ny]) => {\n      if (\n        nx < 0 ||\n        nx >= grid[0].length ||\n        ny < 0 ||\n        ny >= grid.length ||\n        grid[ny][nx] !== char\n      ) {\n        perimeter++;\n      }\n    });\n  }\n\n  return perimeter;\n};\n\nexport default (input: string): number => {\n  const grid = input.split('\\n').map(line => line.split(''));\n\n  const allPoints: Coordinate[] = grid.flatMap((row, y) =>\n    row.map((_, x) => [x, y] as Coordinate),\n  );\n\n  const visited = new Set<string>();\n\n  return allPoints.reduce((totalPrice, point) => {\n    const pointStr = pointToString(point);\n\n    if (visited.has(pointStr)) return totalPrice;\n\n    const region = findRegion(grid, point, visited);\n\n    const area = region.size;\n\n    const perimeter = calculatePerimeter(grid, region);\n\n    return totalPrice + area * perimeter;\n  }, 0);\n};\n",
    "part2": "type Coordinate = [number, number];\ntype Grid = string[][];\n\nconst getNeighbours = (grid: Grid, [x, y]: Coordinate): Coordinate[] => {\n  const neighbours: Coordinate[] = [\n    [x + 1, y],\n    [x - 1, y],\n    [x, y + 1],\n    [x, y - 1],\n  ];\n\n  return neighbours.filter(\n    ([nx, ny]) => nx >= 0 && nx < grid[0].length && ny >= 0 && ny < grid.length,\n  );\n};\n\nconst pointToString = ([x, y]: Coordinate): string => `${x},${y}`;\n\nconst findRegion = (\n  grid: Grid,\n  start: Coordinate,\n  visited: Set<string>,\n): Set<string> => {\n  const region = new Set<string>();\n  const queue: Coordinate[] = [start];\n  const targetChar = grid[start[1]][start[0]];\n\n  while (queue.length > 0) {\n    const current = queue.shift()!;\n    const currentStr = pointToString(current);\n\n    if (visited.has(currentStr)) continue;\n\n    visited.add(currentStr);\n    region.add(currentStr);\n\n    const newNeighbours = getNeighbours(grid, current).filter(n => {\n      const [nx, ny] = n;\n      return grid[ny][nx] === targetChar && !visited.has(pointToString(n));\n    });\n\n    queue.push(...newNeighbours);\n  }\n\n  return region;\n};\n\nconst countSides = (grid: Grid, region: Set<string>): number => {\n  const regionPoints = Array.from(region).map(pointStr =>\n    pointStr.split(',').map(Number),\n  ) as Coordinate[];\n\n  const getNeighbours = ([x, y]: Coordinate): Coordinate[] => {\n    return [\n      [x + 1, y],\n      [x - 1, y],\n      [x, y + 1],\n      [x, y - 1],\n    ];\n  };\n\n  const isInRegion = (point: Coordinate): boolean => {\n    return region.has(point.join(','));\n  };\n\n  let neighboursSet = new Set<Coordinate>();\n\n  for (const point of regionPoints) {\n    getNeighbours(point)\n      .filter(n => !isInRegion(n))\n      .forEach(point => neighboursSet.add(point));\n  }\n\n  const sides = Array.from(neighboursSet).reduce((sides, point) => {\n    const adjacentSides = sides.filter((pointsOnSide, i) => {\n      const isAdjacent = pointsOnSide.some(p => {\n        const [px, py] = p;\n        const [x, y] = point;\n        const dx = Math.abs(px - x);\n        const dy = Math.abs(py - y);\n        return dx + dy === 1;\n      });\n\n      return isAdjacent;\n    });\n\n    if (adjacentSides.length === 0) {\n      sides.push([point]);\n      return sides;\n    }\n\n    adjacentSides.forEach(side => {\n      side.push(point);\n    });\n\n    return sides;\n  }, [] as Coordinate[][]);\n\n  (() => {\n    const neighbours = Array.from(neighboursSet);\n    const minX = Math.min(...neighbours.map(p => p[0]));\n    const maxX = Math.max(...neighbours.map(p => p[0]));\n    const minY = Math.min(...neighbours.map(p => p[1]));\n    const maxY = Math.max(...neighbours.map(p => p[1]));\n\n    const debugGrid = Array.from({ length: maxY - minY + 1 }, () =>\n      Array.from({ length: maxX - minX + 1 }, () => []),\n    );\n\n    let chars = 'abcdefghijklmnopqrstuvwxyz';\n    for (const side of sides) {\n      for (const point of side) {\n        const [x, y] = point;\n        const id = chars[sides.indexOf(side)];\n        debugGrid[y - minY][x - minX].push(id);\n      }\n    }\n\n    for (let y = minY; y <= maxY; y++) {\n      for (let x = minX; x <= maxX; x++) {\n        if (isInRegion([x, y])) {\n          debugGrid[y - minY][x - minX].push('â—™');\n        }\n      }\n    }\n\n    console.table(\n      debugGrid.map(row =>\n        row\n          .map((charArr): string => {\n            const char = charArr.join('');\n            return char.padEnd(4, ' ');\n          })\n          .join(' '),\n      ),\n    );\n  })();\n\n  return sides.length;\n};\n\nexport default (input: string): number => {\n  const grid = input.split('\\n').map(line => line.split(''));\n\n  const allPoints: Coordinate[] = grid.flatMap((row, y) =>\n    row.map((_, x) => [x, y] as Coordinate),\n  );\n\n  const visited = new Set<string>();\n\n  return allPoints.reduce((totalPrice, point) => {\n    const pointStr = pointToString(point);\n\n    if (visited.has(pointStr)) return totalPrice;\n\n    const region = findRegion(grid, point, visited);\n\n    const area = region.size;\n\n    const sides = countSides(grid, region);\n    const char = grid[point[1]][point[0]];\n    console.table({ char, sides });\n\n    return totalPrice + area * sides;\n  }, 0);\n};\n"
  }
}