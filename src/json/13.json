{
  "meta": {
    "createdAt": 1764579151852
  },
  "puzzle": {
    "day": 13,
    "title": "Claw Contraption"
  },
  "notes": "",
  "solutions": {
    "part1": "import {\n  split,\n  map,\n  pipe,\n  filter,\n  sum,\n  reduce,\n  gt,\n  tap,\n  length,\n  flip,\n} from 'rambda';\n\ntype Coordinate = [number, number];\ntype Machine = {\n  a: Coordinate;\n  b: Coordinate;\n  target: Coordinate;\n};\n\nconst extractCoords = (line: string): Coordinate => {\n  const coordString = line.split(': ')[1];\n  const [x, y] = coordString.split(', ').map(coord => {\n    const num = coord.match(/[+-]?\\d+/)?.[0] ?? '0';\n    return parseInt(num, 10);\n  });\n  return [x, y];\n};\n\nconst hasSolution = ({ a: [ax, ay], b: [bx, by], target: [tx, ty] }: Machine) =>\n  tx % gcd(ax, bx) === 0 && ty % gcd(ay, by) === 0;\n\n// Greatest common divisor\nconst gcd = (a: number, b: number): number => (b === 0 ? a : gcd(b, a % b));\n\nconst extendedGcd = (\n  a: number,\n  b: number,\n): {\n  gcd: number;\n  x: number;\n  y: number;\n} => {\n  if (b === 0) {\n    return { gcd: a, x: 1, y: 0 };\n  }\n\n  // Recursively solve for smaller numbers\n  const { gcd, x: x1, y: y1 } = extendedGcd(b, a % b);\n\n  // Work backwards to find x and y\n  const x = y1;\n  const y = x1 - Math.floor(a / b) * y1;\n\n  return { gcd, x, y };\n};\n\nconst findValidSolutions = (\n  coefA: number,\n  coefB: number,\n  target: number,\n): Coordinate[] => {\n  const { gcd, x, y } = extendedGcd(coefA, coefB);\n\n  const scale = target / gcd;\n  const a0 = x * scale;\n  const b0 = y * scale;\n\n  const stepA = coefB / gcd;\n  const stepB = coefA / gcd;\n\n  const solutions: Coordinate[] = [];\n\n  for (let k = -2000; k <= 2000; k++) {\n    const a = a0 + stepA * k;\n    const b = b0 - stepB * k;\n\n    if (a >= 0 && a <= 100 && b >= 0 && b <= 100) {\n      if (coefA * a + coefB * b === target) {\n        solutions.push([a, b]);\n      }\n    }\n  }\n\n  return solutions;\n};\n\nconst findOverlappingSolutions = (machine: Machine): Coordinate[] => {\n  const {\n    a: [ax, ay],\n    b: [bx, by],\n    target: [tx, ty],\n  } = machine;\n\n  const xSolutions = findValidSolutions(ax, bx, tx);\n  const ySolutions = findValidSolutions(ay, by, ty);\n\n  return xSolutions.filter(([x1, y1]) =>\n    ySolutions.some(([x2, y2]) => x1 === x2 && y1 === y2),\n  );\n};\n\nconst aCost = 3;\nconst bCost = 1;\nconst calculateCost = ([a, b]: [number, number]): number =>\n  aCost * a + bCost * b;\n\nconst parseMachine = pipe(split('\\n'), lines => ({\n  a: extractCoords(lines[0]),\n  b: extractCoords(lines[1]),\n  target: extractCoords(lines[2]),\n}));\n\nconst flippedGt = flip(gt);\n\nconst getLowestCost = (min: Coordinate, solution: Coordinate) =>\n  calculateCost(solution) < calculateCost(min) ? solution : min;\n\nexport default pipe(\n  split('\\n\\n'),\n  map(parseMachine),\n  filter(hasSolution),\n  map(findOverlappingSolutions),\n  filter(pipe(length, flippedGt(0))),\n  map(solutions => reduce(getLowestCost, solutions[0])(solutions)),\n  filter(Boolean),\n  map(calculateCost),\n  sum,\n);\n",
    "part2": "export default (input: string): number => {\n  return NaN;\n};\n"
  }
}