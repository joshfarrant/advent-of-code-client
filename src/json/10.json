{
  "meta": {
    "createdAt": 1733932087245
  },
  "puzzle": {
    "day": 10,
    "title": "Hoof It"
  },
  "notes": "",
  "solutions": {
    "part1": "import { map, filter, pipe, curry, sum } from 'rambda';\n\nconst stringTo2DArray = (str: string): number[][] =>\n  str.split('\\n').map(x => x.split('').map(Number));\n\ntype Coordinate = [y: number, x: number];\ntype Direction = [dy: number, dx: number];\n\nconst directions: Direction[] = [\n  [-1, 0],\n  [1, 0],\n  [0, -1],\n  [0, 1],\n];\n\nconst findStarts = (grid: number[][]): Coordinate[] => {\n  const starts: Coordinate[] = [];\n\n  for (let y = 0; y < grid.length; y++) {\n    for (let x = 0; x < grid[y].length; x++) {\n      if (grid[y][x] === 0) starts.push([y, x]);\n    }\n  }\n\n  return starts;\n};\n\nconst isInBounds = (grid: number[][], [y, x]: Coordinate): boolean =>\n  y >= 0 && y < grid.length && x >= 0 && x < grid[y].length;\n\nconst getValidMoves = (grid: number[][], [y, x]: Coordinate): Coordinate[] => {\n  const value = grid[y][x];\n\n  return pipe<[Direction[]], Coordinate[], Coordinate[], Coordinate[]>(\n    map(([dy, dx]) => [y + dy, x + dx]),\n    filter(([y, x]) => isInBounds(grid, [y, x])),\n    filter(([y, x]) => grid[y][x] === value + 1),\n  )(directions);\n};\n\nconst countCompletePaths = (\n  grid: number[][],\n  [y, x]: Coordinate,\n  reachableNines = new Set<string>(),\n): number => {\n  const value = grid[y][x];\n\n  if (value === 9) {\n    reachableNines.add(`${y},${x}`);\n    return 0;\n  }\n\n  getValidMoves(grid, [y, x]).forEach(coord =>\n    countCompletePaths(grid, coord, reachableNines),\n  );\n\n  return reachableNines.size;\n};\n\nexport default (input: string): number => {\n  const grid = stringTo2DArray(input);\n  const countCompletePathsOnGrid = curry(countCompletePaths)(grid);\n\n  return pipe(findStarts, map(countCompletePathsOnGrid), sum)(grid);\n};\n",
    "part2": "import { map, filter, pipe, curry, sum } from 'rambda';\n\nconst stringTo2DArray = (str: string): number[][] =>\n  str.split('\\n').map(x => x.split('').map(Number));\n\ntype Coordinate = [y: number, x: number];\ntype Direction = [dy: number, dx: number];\n\nconst directions: Direction[] = [\n  [-1, 0],\n  [1, 0],\n  [0, -1],\n  [0, 1],\n];\n\nconst findStarts = (grid: number[][]): Coordinate[] => {\n  const starts: Coordinate[] = [];\n\n  for (let y = 0; y < grid.length; y++) {\n    for (let x = 0; x < grid[y].length; x++) {\n      if (grid[y][x] === 0) starts.push([y, x]);\n    }\n  }\n\n  return starts;\n};\n\nconst isInBounds = curry(\n  (grid: number[][], [y, x]: Coordinate): boolean =>\n    y >= 0 && y < grid.length && x >= 0 && x < grid[y].length,\n);\n\nconst getValidMoves = curry(\n  (grid: number[][], [y, x]: Coordinate): Coordinate[] => {\n    const value = grid[y][x];\n    const isWithinGrid = isInBounds(grid);\n\n    return pipe<[Direction[]], Coordinate[], Coordinate[], Coordinate[]>(\n      map(([dy, dx]) => [y + dy, x + dx]),\n      filter(isWithinGrid),\n      filter(([y, x]) => grid[y][x] === value + 1),\n    )(directions);\n  },\n);\n\nconst countCompletePaths = curry(\n  (grid: number[][], [y, x]: Coordinate): number => {\n    const value = grid[y][x];\n\n    if (value === 9) {\n      return 1;\n    }\n\n    return pipe(\n      getValidMoves(grid),\n      map(countCompletePaths(grid)),\n      sum,\n    )([y, x]);\n  },\n);\n\nexport default (input: string): number => {\n  const grid = stringTo2DArray(input);\n\n  return pipe(findStarts, map(countCompletePaths(grid)), sum)(grid);\n};\n"
  }
}